Создадим папку, где будут храниться наши виртуальные окружения, и перейдем в неё:

C:\DENIS\mkdir environments


cd C:\Users\DEN\environments
selenium_env\Scripts\activate.bat
cd C:\Users\DEN\environments\selenium_env\Scripts
python C:\Users\DEN\environments\selenium_course\


Создадим виртуальное окружение:

python -m venv selenium_env

Запустим созданный для нас приложением venv файл activate.bat, чтобы активировать окружение:

selenium_env\Scripts\activate.bat

Проверим, что мы можем теперь использовать Python. Запустим интерпретатор Python и напишем собственную версию HelloWorld:

> selenium_env\Scripts\activate.bat

(selenium_env) С:\Users\Юлия\environments> python
 
>>> print("Hello, Selenium!")
В итоге вы должны увидеть вывод строки "Hello, Selenium! "
Выйдем из интерпретатора:

>>> exit()

В нашем виртуальном окружении установим библиотеку Selenium:

pip install selenium==4.*

Проект Selenium развивается очень быстро и в вашей установленной версии библиотеки могут быть расхождения в методах или в том, что библиотека выводит в терминал при выполнении скриптов. Если вы просите помощи в комментариях, пожалуйста, указывайте версии python-библиотек, которые вы используете. Версии библиотек в вашем виртуальном окружении можно узнать с помощью команды pip list.
Проверим, что библиотека действительно установлена:

pip list

Драйвер для Chrome разрабатывается командой браузера и носит название ChromeDriver. Скачать нужную версию можно с официального сайта по ссылке
https://googlechromelabs.github.io/chrome-for-testing/#stable



import time

# webdriver это и есть набор команд для управления браузером
from selenium import webdriver

# импортируем класс By, который позволяет выбрать способ поиска элемента
from selenium.webdriver.common.by import By

# инициализируем драйвер браузера. После этой команды вы должны увидеть новое открытое окно браузера
driver = webdriver.Chrome()

# команда time.sleep устанавливает паузу в 5 секунд, чтобы мы успели увидеть, что происходит в браузере
time.sleep(5)

# Метод get сообщает браузеру, что нужно открыть сайт по указанной ссылке
driver.get("https://suninjuly.github.io/text_input_task.html")
time.sleep(5)

# Метод find_element позволяет найти нужный элемент на сайте, указав путь к нему. Способы поиска элементов мы обсудим позже
# Метод принимает в качестве аргументов способ поиска и значение, по которому мы будем искать
# Ищем поле для ввода текста
textarea = driver.find_element(By.CSS_SELECTOR, ".textarea")

# Напишем текст ответа в найденное поле
textarea.send_keys("get()")
time.sleep(5)

# Найдем кнопку, которая отправляет введенное решение
submit_button = driver.find_element(By.CSS_SELECTOR, ".submit-submission")

# Скажем драйверу, что нужно нажать на кнопку. После этой команды мы должны увидеть сообщение о правильном ответе
submit_button.click()
time.sleep(5)

# После выполнения всех действий мы должны не забыть закрыть окно браузера
driver.quit()




c:\Users\DEN> mkdir selenium_course

C:\Users\DEN> copy C:\Users\DEN\Downloads\first_script.py c:\Users\DEN\selenium_course

C:\Users\DEN> environments\selenium_env\Scripts\activate.bat

(selenium_env) C:\Users\DEN>python C:\Users\DEN\environments\selenium_course\first_script.py




find_element(By.ID, value) — поиск по уникальному атрибуту id элемента. Если ваши разработчики проставляют всем элементам в приложении уникальный id, то вам повезло, и вы чаще всего будет использовать этот метод, так как он наиболее стабильный;
find_element(By.CSS_SELECTOR, value) — поиск элемента с помощью правил на основе CSS. Это универсальный метод поиска, так как большинство веб-приложений использует CSS для вёрстки и задания оформления страницам. Если find_element_by_id вам не подходит из-за отсутствия id у элементов, то скорее всего вы будете использовать именно этот метод в ваших тестах;
find_element(By.XPATH, value) — поиск с помощью языка запросов XPath, позволяет выполнять очень гибкий поиск элементов;
find_element(By.NAME, value) — поиск по атрибуту name элемента;
find_element(By.TAG_NAME, value) — поиск элемента по названию тега элемента;
find_element(By.CLASS_NAME, value) — поиск по значению атрибута class;
find_element(By.LINK_TEXT, value) — поиск ссылки на странице по полному совпадению;
find_element(By.PARTIAL_LINK_TEXT, value) — поиск ссылки на странице, если текст селектора совпадает с любой частью текста ссылки.